---
title: "Trading based on RSI"
author: "Mark Ziemann"
date: "`r Sys.Date()`"
output:
  html_document:
    toc: true
theme: cosmo
---

## Intro

In this blog post I will be trilaing using RSI for entry and exit.

```{r,lib}

library("jsonlite")
library("tidyverse")
library("runner")
library("quantmod")
library("TTR")
library("vioplot")
library("parallel")

knitr::opts_chunk$set(fig.width=8, fig.height=8) 

```

## Get data

Obtaining BTC historical data (daily).

```{r,getdata}

mydate <- Sys.Date()-1

URL=paste("https://web-api.coinmarketcap.com/v1/cryptocurrency/ohlcv/historical?symbol=BTC&convert=USD&interval=daily&time_start=2013-06-01&time_end=",mydate,sep="")

if ( ! file.exists("btcdat.txt") ) {
  download.file(URL,destfile="btcdat.txt")
}

btcdat <- fromJSON("btcdat.txt")
price <- btcdat$data$quotes
price <- data.frame(price$time_close,price$quote$USD$close,stringsAsFactors=FALSE)
colnames(price) <- c("date","Close")
price$date <- sapply(strsplit(price$date,"T"),"[[",1)

```

## Calculate hodl returns

```{r,hodl}

myend <- price[c(1,nrow(price)),2][2] 
mystart <- price[c(1,nrow(price)),2][1] 
hodl <- (myend - mystart) / mystart
hodl

```

## RSI analysis

FEES: Assuming 0.1% trading fee, as per binance current rate.

The idea here is to enter after RSI recovers from a low point and then recovers to positive territory.

Exit when RSI stops increasing


```{r,rsi}

n=14
window=5

rsi <- RSI(price$Close,n=14)

change <- unlist(sapply(window:length(rsi) , function(x) {
  return( rsi[x] - rsi[(x-5)]) 
}))

change <- c(rep(NA,nrow(price) - length(change)), change)

price <- data.frame(price,rsi,change,stringsAsFactors=FALSE)

price$low <- change < -20
price$high <- change > 20

par(mfrow=c(2,1))
plot(price$Close~ as.Date(price$date),type="l",log="y",xlab="",ylab="USD price")
grid()
plot(price$rsi ~ as.Date(price$date),type="l",xlab="",ylab="RSI")
grid()
abline(h=30,col="red")
abline(h=70,col="red")

```





```{r,rsi 30 70}

btcdat <- fromJSON("btcdat.txt")
price <- btcdat$data$quotes
price <- data.frame(price$time_close,price$quote$USD$close,stringsAsFactors=FALSE)
colnames(price) <- c("date","Close")
price$date <- sapply(strsplit(price$date,"T"),"[[",1)

rsisig <- function(price,vals=x,fee) {
n_rsi < vals[1]
entry <- vals[2]
exit <- vals[3]
rsi <- RSI(Cl(price),n=n_rsi)
rsiy <- c(NA,rsi)[1:nrow(price)]
price2 <- data.frame(price,rsi,rsiy,stringsAsFactors=FALSE)
price2$sell <- as.numeric(apply(price2,1, function(x) { x[3] > entry && x[4] < entry }))
price2$buy <- as.numeric(apply(price2,1, function(x) { x[3] < exit && x[4] > exit }))
price2 <- subset(price2, buy == 1 | sell == 1)
price2$y <- c(NA,price2$buy)[1:nrow(price2)]
price2 <- price2[which(price2$buy != price2$y),]
buy <- subset(price2,buy==1)[c(1,2)]
colnames(buy) <- c("buy_date","buy_price")
sell <- subset(price2,sell==1)[c(1,2)]
colnames(sell) <- c("sell_date","sell_price")
if( nrow(buy) != nrow(sell) ) {
  MIN=min(nrow(buy),nrow(sell))
  buy <- buy[1:MIN,]
  sell <- sell[1:MIN,]
}
trades <- cbind(buy,sell)
trades$diff <- ( ( trades$sell_price - trades$buy_price ) / trades$buy_price ) +1 - ( 2 * fee )
return(prod(trades$diff))
}


```

## Backtesting

```{r,backtest}

fee=0.001
n_rsi=14

mymx <- expand.grid(3:20,seq(0,100,5),seq(0,100,5))

mylist <- as.list(as.data.frame(t(mymx)))

res_rsi_sig <- mclapply(X=mylist,mc.cores=7,FUN=function(x) { rsisig(price,vals=x,fee) })

mymx$res <- unlist(res_rsi_sig)

mymx <- mymx[which(!is.na(mymx$res)),]

head(mymx[order(-mymx$res),],30)

```

## Conclusion

RSI doesn't appear to be very good on its own.

## Session information

For reproducibility

```{r,sessioninfo}

sessionInfo()

```
